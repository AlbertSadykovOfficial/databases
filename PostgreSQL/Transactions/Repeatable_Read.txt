

		Уровень Repeatable Read

				СУТЬ:

						Позволяет работать с данными, которые были выбраны при старте транзакции.
						Так, снимок данных делается только перед выполнением первого запроса.

						Это значит, что если, к примеру, таблица изменится в процессе работы другой транзакции,
						то мы проигнорируем эти изменения и все равно будем иметь данные, которые были
						изначально в таблице (при начале работы этой транзакции).

						Т.е. устраняется феномен неповторяющегося чтения данных.  

						При этом данные транзакции не могут изменять строки, которые были изменены
						другими завершившимися транзакциями уже после создания снимка.



				Для теста создадим копию таблицы aircrafts (если еще не создали), чтобы оттуда данные не удлялись:

						CREATE TABLE aircrafts_tmp AS SELECT * FROM aircrafts;


				Начнем транзакцию и установим уровень изоляции Read Committed НА 2х терминалах:

						Терминалы №1 и №2:
							
								BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;


				Добавим строку и обновим:

						Терминал №2:

								INSERT INTO aircraft_tmp VALUES ( 'IL9', 'Ilyushin IL96', 9800 );
								
								UPDATE aircraft_tmp 
									 SET range = range + 100 
								 WHERE aircraft_code = '320' 

								END;


						Терминал №1:

								SELECT * FROM aircraft_tmp;
								( Таблица точно такая же как и была при старте тракзакции )
								
								END;

								SELECT * FROM aircraft_tmp;
								( Таблица поменялась, добавлена одна строка и одна изменена)


				
				Демонстрация ошибок сериализации:

						Начнем тразакцию на терминалах:

								Терминал №1

										BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

										UPDATE aircraft_tmp
											 SET range = range + 100
										 WHERE aircraft_code = '320'

								Терминал №2

										BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

										UPDATE aircraft_tmp
											 SET range = range + 200
										 WHERE aircraft_code = '320';

								Теринал №1

										END;

										(
												Во втором терминале возбудится Ошибка: 
												Не удалось сериализовать доступ из-за параллельного изменения

												Это потому что на момент выполнения запроса во второй транзакции,
												то возникает эта ошибка.

												При выполнении обновления строки команда UPDATE во 2й транзакции видит,
												что строка уже изменена.
												Так как новые версии строки считываются только при первом запросе, тогда
												обновление данных во 2й транзакци без повторного считывания приводят
												к потерянное обновление. -> Генерируется ошибка -> Откат 2й транзакции.

										)
								Терминал №2
										Исходя из вышесказанного, при завершении Транзакции будет выполнн откат:

										END; 
										(Результат: ROLLBACK);

										SELECT * FROM aircrafts_tmp WHERE aircraft_code = '320';