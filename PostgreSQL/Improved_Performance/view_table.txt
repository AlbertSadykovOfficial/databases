

		Методы просмотра таблиц

				Прежде чем выполнить апрос PostgreSQL строит план его выполнения.
				Планированием занимается подсисетма - Планировщик (planner)

				Структура плана представялет собой дерево, состоящее из узлов Плана (plan nodes).
				Узлы нижних урвоней - просмотр и выдача строк.
				Выше идут узлы агрегирования, сортировки и тд.

				Для каждого запроса планирует несколько плнов и выбирает лучший,
				но можно выбрать и тот, который нам нужен через курсор:
						cursor_tuple_fraction (читать дополнительно)


				!!! ВСЕ действия в результатах EXPLAIN идут снизу вверх.

				Посмотреть план выполения можно камандой EXPLAIN:

						EXPLAIN SELECT * FROM aircrafts;

						Результат:
								Seq Scan on aircrafts (cost=0.00..1.09 rows=9 width=52)

								Seq Scan - последовательный просмотр (потому что нужна вся таблицаю)
								cost {
											0.00 - оценка, сколько ресурсво потрачено, чтобы приступить к операции вывода.
														 Равна нулю, так как доп операций не требуется и PostgreSQL
														 сразу ожет вывести результат
											1.09 - оценка общей стоимости выполнения запроса.
										 }

								Оценки 0.00 и 1.09 - условны, важны их соотношения, а не они сами.

								rows=9 - ощее число строк, которое должно быть извлечено

				Если нужно посмотреть план без численных оценок, то следует исп. след. команду:

						EXPLAIN ( COSTS OFF ) SELECT * FROM aircrafts;

				Если к запросу добавлять условия, то к плану добавятся доп узлы:

						WHERE -> Filter ()
						ORDER BY -> Sort Key: <column> 


				Сканирования по индексу (Если мы будем работать с индексированными столбцами):

						EXPLAIN SELECT * FROM bookings
									WHERE book_ref > '0000FF' AND book_ref < '000FFF'
									ORDER BY book_ref;

						Результат:

								Index Scan using bookings_pkey on bookings (cost=0.42...8511.4 ...)
									Index Cond: ((book_ref > '0000FF'::bpchar) AND (book_ref < '000FFF'::bpchar))

								Видно, что значение cost не нулевое, это связано с тем, что нужно найти в индексе 1 строку
								в соответствии с требуемым порядком.
								Так как столбец индексируемый, то и отбор реализуется через Index, а не через Filter

				
				Сканирование на основе битовой карты

						EXPLAIN SELECT * FROM seats WHERE aircraft_code = 'SU9';

							результат:
									При создании битовой карты width=0, так как на этом этапе строки еще не выбираются

				Сканирование искючительно по индексу
						
						(Если потребуется номера бронирования в каком-то диапазоне, то обращаться к таблице не потребуется)

						EXPLAIN SELECT book_ref 
							 FROM bookings
							WHERE book_ref < '000FFF'
							ORDER BY book_ref;


						Результат:

								Index Only Scan using bookings_pkey on bookings (cost=0.42 ..)

				Отражение в планах агрегатных функций

						EXPLAIN SELECT count ( * )
							 FROM seats
							WHERE aircraft_code = 'SU9';

							Рузльтат:
								Aggregate (...)
									Bitpmap Heap Scan()
										...

								Заметим, что при подсчете сток потребовалось обращение к строкам таблицы Bitpmap Heap Scan,
								даже при том, что никакие значения атрибутов не выбираются.
								Это нужно, чтобы проверить видимость действий строк (нужно учитывать какой транзакции они видны).